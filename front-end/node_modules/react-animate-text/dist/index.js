'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var rxjs = require('rxjs');
var operators = require('rxjs/operators');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var context = React.createContext({
    charInterval: 200,
    animation: 'type',
    onComplete: undefined,
    onNextChar: undefined,
    caret: undefined,
});
var Provider = context.Provider, Consumer = context.Consumer;

var getSource$ = function (charInterval, limit) {
    return rxjs.interval(charInterval).pipe(operators.map(function (val) { return val + 1; }), operators.take(limit));
};
var Text = (function (_super) {
    __extends(Text, _super);
    function Text() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            currentText: _this.context.animation === 'type' ? '' : _this.props.children,
        };
        _this.getCurrentText = function (currentCharIndex) {
            var animation = _this.context.animation;
            var children = _this.props.children;
            switch (animation) {
                case 'delete':
                    return children.substring(currentCharIndex);
                case 'backspace':
                    return children.substring(0, children.length - currentCharIndex);
                case 'type':
                default:
                    return children.substring(0, currentCharIndex);
            }
        };
        _this.onNextChar = function () {
            var currentText = _this.state.currentText;
            return _this.context.onNextChar && _this.context.onNextChar(currentText);
        };
        return _this;
    }
    Text.prototype.componentDidMount = function () {
        var _this = this;
        var children = this.props.children;
        var _a = this.context, charInterval = _a.charInterval, onComplete = _a.onComplete;
        this.subscription = getSource$(charInterval, children.length).subscribe({
            next: function (index) {
                return _this.setState({ currentText: _this.getCurrentText(index) }, _this.onNextChar);
            },
            complete: function () { return onComplete && onComplete(); },
        });
    };
    Text.prototype.componentWillUnmount = function () {
        this.subscription.unsubscribe();
    };
    Text.prototype.render = function () {
        return this.state.currentText;
    };
    Text.contextType = context;
    Text.defaultProps = {
        charInterval: 200,
        type: 'type',
    };
    return Text;
}(React.Component));

var TextWrapper = (function (_a) {
    var text = _a.text;
    return (React.createElement(Consumer, null, function (_a) {
        var caret = _a.caret, animation = _a.animation;
        return (React.createElement(React.Fragment, null,
            animation === 'delete' && (caret || null),
            React.createElement(Text, null, String(text)),
            animation !== 'delete' && (caret || null)));
    }));
});

var EMPTY_STRING = '';

function getOutputData (allChildren, wrappedTextIndex, animation) {
    if (wrappedTextIndex === void 0) { wrappedTextIndex = 0; }
    if (animation === void 0) { animation = 'type'; }
    var textCounter = 0;
    var wrapChildren = function (children) {
        var childrenArray = animation === 'backspace'
            ? React.Children.toArray(children).reverse()
            : React.Children.toArray(children);
        var wrappedChildren = childrenArray.map(function (child) {
            if (React.isValidElement(child) && child.props.children) {
                return React.cloneElement(child, __assign({}, child.props, { children: wrapChildren(child.props.children) }));
            }
            if (['string', 'number'].includes(typeof child)) {
                var textPosition = textCounter - wrappedTextIndex;
                textCounter++;
                if (textPosition === 0) {
                    return (React.createElement(TextWrapper, { key: textCounter, text: child }));
                }
                return (textPosition > 0 && animation === 'type') ||
                    (textPosition < 0 && animation !== 'type')
                    ? EMPTY_STRING
                    : child;
            }
            return child;
        });
        return animation === 'backspace'
            ? wrappedChildren.reverse()
            : wrappedChildren;
    };
    var output = wrapChildren(allChildren);
    return {
        output: output,
        isLastText: textCounter - wrappedTextIndex === 1,
    };
}

var TextAnimation = (function (_super) {
    __extends(TextAnimation, _super);
    function TextAnimation() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.state = {
            currentTextIndex: 0,
        };
        _this.increaseCurrentText = function () {
            return _this.setState(function (_a) {
                var currentTextIndex = _a.currentTextIndex;
                return ({
                    currentTextIndex: currentTextIndex + 1,
                });
            });
        };
        return _this;
    }
    TextAnimation.prototype.render = function () {
        var _a = this.props, children = _a.children, charInterval = _a.charInterval, animation = _a.animation, onNextChar = _a.onNextChar, caret = _a.caret;
        var currentTextIndex = this.state.currentTextIndex;
        var _b = getOutputData(children, currentTextIndex, animation), output = _b.output, isLastText = _b.isLastText;
        return (React.createElement(Provider, { value: {
                charInterval: charInterval,
                animation: animation,
                onComplete: isLastText ? null : this.increaseCurrentText,
                onNextChar: onNextChar,
                caret: caret,
            } }, output));
    };
    TextAnimation.defaultProps = {
        animation: 'type',
        charInterval: 200,
    };
    return TextAnimation;
}(React.Component));

exports.Text = Text;
exports.default = TextAnimation;
//# sourceMappingURL=index.js.map
